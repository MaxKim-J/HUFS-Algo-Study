#선택 알고리즘
2020.02.09

**선택 알고리즘이란?**
배열 A[p...r]에서 i번째 작은 원소를 찾는 알고리즘


##평균 선형시간 선택 알고리즘

퀵정렬처럼 분할한 후 자기호출 방법 사용한다.
다음은 평균 선형시간 선택 알고리즘의 작동 예시다.

10개의 원소로 구성된 배열에서 2번째 작은 원소를 찾을 때,
[31, 8, 48, 73, 11, 3, 20, 29, 65, 15]
1. 퀵정렬의 partition 함수로 pivot 15를 기준으로 분할한다.
[8, 11, 3, 15, 31, 48, 20, 65, 73]
-> L의 갯수는 3개, R의 갯수는 6개
2. 2번째로 작은 원소는 L에 있다
3. 작아진 배열 L에서 2번째로 작은 원소를 1과 같은 방법으로 찾는다.
***
 - Pseudo code
 ```shell
 select(A, p, r, i)
 {
   if (p = r) then return A[p];
   # 첫번째 원소와 마지막 원소가 같은 경우, 즉 원소가 하나뿐일 때 그 원소를 return
   q <- partition(A, p, r); # A[r]의 index return하여 대입
   k <- q-p+1; #k는 pivot의 index
   #k=q를 안하는 이유는 p가 0보다 커서 index 0~(p-1)를 무시하고 크기 비교를 할 수 있기 때문이겠지...?
   if (i < k) then return select(A, p, q-1, i); # 왼쪽 그룹으로 범위를 좁힘
   else if (i = k) then return A[q]; # 기준 원소가 바로 찾는 원소임
   else return select(A, q+1, r, i-k); # 오른쪽 그룹으로 범위를 좁힘
 }
 ```

 - Python
```python
def partition(arr, l, r):
    x = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= x:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1

    arr[i], arr[r] = arr[r], arr[i]
    return i


def select(arr, p, r, i):
    if (p == r):
        return arr[p]

    q = partition(arr, p, r)
    k = q - p + 1

    if (i < k):
        return select(arr, p, q - 1, i)
    elif (i == k):
        return arr[q]
    else:
        return select(arr, q + 1, r, i - k)

# 실행코드
arr = [ 10, 4, 5, 8, 6, 11, 26 ]
n = len(arr)
k = 3
print("K-th smallest element is ", end = "")
print(select(arr, 0, n - 1, k))
```

- 평균 수행 시간 분석 : O(n)
```
T(n) <= max[T(k-1), T(n-k)]+ O(n)
```
O(n)은 재귀함수를 제외한 오버헤드(분할이 대부분)
T(n)<= cn 임을 추정하여, T(n)= O(n) 증명할 수 있다.
~~세부 증명과정은 책 참조..~~

- 최악의 수행시간 분석 : O(n^2)
최악의 경우는 분할 결과가 0:n-1로 계속 분할이 되어 찾고자 하는 원소가 운이 나쁘게 큰 그룹에 계속 속할 때이다.
이 때 수행시간 점화식은 다음과 같다
```
T(n)= T(n-1)+O(n)
```
T(n)= O(n^2)이므로 이 단점을 개선한 알고리즘이 필요하다.

##최악의 경우에도 선형시간을 보장하는 선택 알고리즘
분할의 균형이 아주 나빠보여도 일정한 상수비만 넘지 않으면 점근적 복잡도는 항상 O(n)이다. 단, 균형을 맞추는 오버헤드가 너무 커지면 안된다.
이 알고리즘은 직접 코드를 상세히 기술하는 것보다 어떻게 작동하는 지 알고 수행시간을 이해하는 것을 목표로 한다.
```shell
linearSelect(A, p, r, i)
{
  1. 원소의 총 갯수가 5개 이하이면 i번째 원소를 찾고 알고리즘을 끝낸다.
  2. 전체 원소를 5개씩의 원소를 가진 [n/5]개의 그룹으로 나눈다
  #원소의 총 갯수가 5의 배수가 아니면 이 중 한 그룹은 원소의 갯수가 5개 미만이다.
  3. 각 그룹에서 중앙값 (5개의 원소일 때 3번째 원소)을 찾는다.
  4. 이 중앙값들의 중앙값 M을 재귀적으로 구한다.
  원소의 갯수가 홀수이면 중앙 값이 하나이고, 짝수이면 두 중앙값 중 임의로 선택한다. (call linearSelect())
  5. M을 기준 원소로 삼아 전체 원소를 분할한다. (call partiton())
  6. 분할된 두 그룹 중 적합한 쪽을 선택해 1~6을 재귀적으로 반복한다. (call linearSelect())

}
```
![이미지](https://imgur.com/LxFWJLp.jpg)
M보다 큰 원소들의 개수 계산방법:
[n/5]()그룹의 갯수)/2(중앙값이 M이상인 그룹)*3(각 그룹에서 중앙값보다 큰 값이 다 있을 때)-3(M과 마지막 그룹에서 중앙값이상 원소가 없을 때, 즉 최소일 때) = 3n/10-3개의 원소
``M을 포함한 원소의 갯수 3n/10-2개``
``나머지 모든 원소는 많아야 n-(3n/10-2)=7n/10+2개``
``최악의 경우일 때 분할 비율: 7n/10+2:3n/10-3 (대략 7:3)``

- 수행시간 분석
```shell
linearSelect(A, p, r, i)
{
  1. 원소의 총 갯수가 5개 이하이면 i번째 원소를 찾고 알고리즘을 끝낸다.
  = 전체 수행시간에 영향을 주지 않음
  2. 전체 원소를 5개씩의 원소를 가진 [n/5]개의 그룹으로 나눈다
  #원소의 총 갯수가 5의 배수가 아니면 이 중 한 그룹은 원소의 갯수가 5개 미만이다.
  = O(n)
  3. 각 그룹에서 중앙값 (5개의 원소일 때 3번째 원소)을 찾는다.
  = O(n)
  4. 이 중앙값들의 중앙값 M을 재귀적으로 구한다.
  원소의 갯수가 홀수이면 중앙 값이 하나이고, 짝수이면 두 중앙값 중 임의로 선택한다. (call linearSelect())
  = O(n)
  5. M을 기준 원소로 삼아 전체 원소를 분할한다. (call partiton())
  = O(n)
  6. 분할된 두 그룹 중 적합한 쪽을 선택해 1~6을 재귀적으로 반복한다. (call linearSelect())
  =O(n)

}
```
수행시간 계산의 관건은 재귀함수를 포함한 4,6 단계이다.
``수행시간 점화식: T(n) <= T([n/5])+ T(7n/10+2)+ O(n)``
~~증명과정 책 참조~~
결과적으로 T(n)<= cn이므로 T(n) = O(n)
